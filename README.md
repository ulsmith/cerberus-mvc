<p align="center">
  <img width="250" height="250" src="cerberus-round-wob-500x500.png">
</p>

# INTRODUCTION

Now Support AWS and ExpressJS (with child processes)

CerberusMVC is simply a node MVC stack, that is used to create API's on FaaS backgrounds such as AWS's lambda, Google clouds compute, Azures function services as well as more natural Express JS setups.

Why would it exist? If you have ever worked in serverless or have been involved with large FaaS architectures, you will soon find diversity brings issues. Diversity in developers, coding styles and rules leads to complicated, fragmented and overlapping capabilities, by virtue of the many individual functions generated by all those invloved. This means in simple terms, a mess. the mess is nto intentional, it just happens as naturally as entropy. We end up with many lambdas/computes/functions written all in slightly different ways, some with similar functionality and a loss of abstraction.

Other issues also exist, such as managing a collection of resources on a function based serverless architecture. You gain the strengths of the seperation and modularity but suffer in lost time, developement, repetion and the ability to orchastrate the collection as an entity in itself.

A FaaS serverless MVC stack offers a cure to both parts of this coin. We abstract the modularity with a known methodology, that of a singlualr MVC stack that works in a regimented way. We also solve orchastration through tools to publish the stacks as their tue modular form through the many ways that the providers give us... an example of this would be SAM from AWS and cloudformation.

We simply build as a singluar MVC stack, test, develop, then publish to moduler resources, best of both worlds. Whilst for some providers, we may need to develop as a single function (azure) due to the innability to have a single routing file, all production pushes will generate individual functions and resources form the stack, wiht the MVC framework only pulling in what is needed for that particular route through the stack. AWS, openfass and forked processes all allow for development in as near to production as possible, with seperate endpoint functions, with azure having to develop in a single funciton and build to many on push. As the stack loads controllers on the fly, whilst we may push a full stack to each function, we will only laods the required items for that path through the system due to this on the fly loading. Future release may offer a more streamlined chunking of files to reduce files on each function, this will nto make any difference to memory when in use, just disk space.

CerberusMVC is a FaaS, serverless MVC architecture that is provider agnostic... currently supporting AWS configuration and Express JS forked server configuration for basic VPS's, with the want to open this up to other platforms such as OpenFaaS, Azure. Our aim is to offer a way to build API's and deploy them easily, for many different providers as demand increases. 

Want to know more, see more of CerberusMVC? We are all about MVP, we are happy to expand documentation, add in more support; let us know your thoughts... [Find me here](https://pa.ulsmith.net).

# INSTALLATION

(recommended) Automatic installation, using the cerberus-cli (linux users might need sudo!). This will install the CLI tool and generate a base project at your current location (installaing cerberus-mvc during the process).

```bash
npm install -g cerberus-cli

cerberus-cli init
```

(not recommended) Manual installation, should you wish to create your won structure.

```bash
npm install cerberus-mvc
```

# STRUCTURE

The basic structure is that of MVC, with controllers, models and obviously the views removed (however you could add these for serving things like email templates to email?). The specific structure is...

* Controller - the entry point in and the exit path out
* Library - any 3rd party bundled things, or maybe your own stuff
* Middleware - middlware that loads in order on in, out or both
* Model - connection to DB through models, connecting to knexjs
* Service - singleton services isntantiated at creation

This structure is generated by the cerberus-cli tool when using the init command. in addition a handler template is generated, this is the bridge between your provider and CerberusMVC, the entry point into the stack. As stated above, controllers are lazy loaded, so we only load what we need for that path through the system, othe rcontroller dependencies will not be loaded unles that controller is lazy loaded when routing form your providers routing logic (e.g. AWS API gateway).

The controller start point is furnished with a request property that is passed into the controller. The request is a generic request that is generated form the providers event, that hits function/lambda/compute. the idea here is that we abstract the provider allowing us to write code that is portable to other providers! the exit path out the controller is a geenric response. Once hte repsonse has passed through middleware, the stack will auto convert it back to the required response for the provider. thi sallows us to generate API's we can port to other providers with minimal changes. The idea here is to offer multiplatform FaaS in MVC form to aid development and allow for simple porting.

All cerberus-mvc base classes expose 3 properties to help you in your apllication (inherited by Core)...

* this.$services - the services loaded into the system as an instantiated singleton
* this.$environment - any environment variables passed into the system (process.env)
* this.$client - any client specific information

In addition to exposed properties, models also gain the raw db object... so it my talk directly to knexjs inside each model

* this.db 

## Routing and Config

Providers need something to instruct them how to handle the functions, route them to gateway logic and also configure stuff. In aws thi sis a AWS template file for Cloud Formation. In azure these are individual files for each function. Thi shandles routing and config fo rhte system too. You will require one of these for your project before you can do anything else.

(AWS Cloud Formation) template.yaml
```yaml
AWSTemplateFormatVersion : '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: cerberus-mvc-<meta.name>

Globals:
  Api:
    Cors:
      AllowMethods: "'GET, POST, PUT, DELETE, OPTIONS, PATCH'"
      AllowHeaders: "'Accept, Cache-Control, Content-Type, Content-Length, Authorization, Pragma, Expires'"
      AllowOrigin: "'*'"
      AllowCredentials: "'*'"
  Function:
    Timeout: 3
    Runtime: nodejs12.x
    Handler: handler.run
    Environment:
      Variables:
        API_NAME: <meta.title>
        API_ADDRESS: 'http://localhost:3000'
        API_VERSION: 0.0.1
        API_MODE: development
        API_CORS_LIST: 'http://localhost:8181' 
        
Resources:
  Health:
    Type: AWS::Serverless::Function
    Properties:
      ReservedConcurrentExecutions: 10
      Timeout: 30
      VpcConfig:
        SecurityGroupIds:
          - sg-0......1
        SubnetIds:
          - subnet-0......1
          - subnet-0......2
      Events:
        HealthGet:
          Type: Api
          Properties:
            Path: /health
            Method: get

  CatchAll:
    Type: AWS::Serverless::Function
    Properties:
      ReservedConcurrentExecutions: 10
      Timeout: 30
      VpcConfig:
        SecurityGroupIds:
          - sg-0......1
        SubnetIds:
          - subnet-0......1
          - subnet-0......2
      ReservedConcurrentExecutions: 10
      Events:
        CatchAll:
          Type: Api
          Properties:
            Path: /{error+}
            Method: any

```

(Express JS) template.json
```yaml
{
	"global": {
		"environment": {
			"API_NAME": "fffffff", 
			"API_ADDRESS": "", 
			"API_VERSION": "", 
			"API_MODE": "", 
			"API_CORS_LIST": "" 
		}
	},
	"resources": [
		{
			"name": "Health",
			"handler": false,
			"environment": { "HEALTH_CONFIG": "dsds" },
			"method": "get",
			"path": "/health"
		},
		{
			"name": "test",
			"handler": false,
			"environment": {
				"API_NAME": "dddddddddd"
			},
			"method": "get",
			"path": "/test/{id}"
		}
	]
}
```

## Handler

The handler file called handler.js is the bridge, it has the initial callback for your provider, allong with instantiation of the stack and loading of middleware and services. It finally returns the reponse abck to the providers ecosystem.

example handler for AWS

(aws) handler.js
```js
'use strict';

const Application = require('cerberus-mvc/System/Application');
const CorsMiddleware = require('cerberus-mvc/Middleware/Cors');
const KnexMiddleware = require('cerberus-mvc/Middleware/Knex');
const KnexService = require('cerberus-mvc/Service/Knex');

exports.run = (event, context, callback) => { 
	const app = new Application('aws');
	const corsMiddleware = new CorsMiddleware(); 
	const knexMiddleware = new KnexMiddleware(); 
	const yourDBKnexService = new KnexService('postgres', '192.168.1.10', 5432, 'your_db', 'your_user', 'your_password'); 
	
	app.service(yourDBKnexService);
	app.middleware(corsMiddleware);
	app.middleware(knexMiddleware);
	
	app.run(event).then((response) => callback(null, response))
};
```

example handler for Express JS

(express) handler.js
```js
'use strict';

const Application = require('cerberus-mvc/System/Application');
const CorsMiddleware = require('cerberus-mvc/Middleware/Cors');
const KnexMiddleware = require('cerberus-mvc/Middleware/Knex');
const KnexService = require('cerberus-mvc/Service/Knex');

const express = require('express');
const requestIp = require('request-ip');
const bodyParser = require('body-parser');
const PORT = 8082;
const server = express();

server.use(requestIp.mw())
server.use(bodyParser.urlencoded({ extended: false }))
server.use(bodyParser.json())

server.use('/', (req, res) => {
	let app = new Application('express');
	let corsMiddleware = new CorsMiddleware();
	let knexMiddleware = new KnexMiddleware();
	let yourDBKnexService = new KnexService('postgres', '192.168.1.10', 5432, 'your_db', 'your_user', 'your_password'); 

	app.service(yourDBKnexService);
	app.middleware(corsMiddleware);
	app.middleware(knexMiddleware);

	return app.run(req).then((response) => res.set(response.headers).status(response.status).send(response.body));
});

// Start
server.listen(PORT, () => console.log('Running on http://localhost:' + PORT));
```

example handler for Express JS with forked processes for multiple CPU cores

(express) handler.js
```js
'use strict';

const os = require("os");
const cluster = require("cluster");
const clusterWorkerSize = os.cpus().length;

const Application = require('cerberus-mvc/System/Application');
const CorsMiddleware = require('cerberus-mvc/Middleware/Cors');
const KnexMiddleware = require('cerberus-mvc/Middleware/Knex');
const KnexService = require('cerberus-mvc/Service/Knex');

const express = require('express');
const requestIp = require('request-ip');
const bodyParser = require('body-parser');
const PORT = 8082;
const server = express();

if (clusterWorkerSize > 1) {
	if (cluster.isMaster) {
		for (let i = 0; i < clusterWorkerSize; i++) cluster.fork()
		cluster.on("exit", (worker) => console.log("Worker", worker.id, " has exitted."));
	} else process();
} else process();

function process() {
	server.use(requestIp.mw())
	server.use(bodyParser.urlencoded({ extended: false }))
	server.use(bodyParser.json())

	server.use('/', (req, res) => {
		let app = new Application('express');
		let corsMiddleware = new CorsMiddleware();
		let knexMiddleware = new KnexMiddleware();
		let yourDBKnexService = new KnexService('postgres', '192.168.1.10', 5432, 'your_db', 'your_user', 'your_password');

		app.service(yourDBKnexService);
		app.middleware(corsMiddleware);
		app.middleware(knexMiddleware);

		return app.run(req).then((response) => res.set(response.headers).status(response.status).send(response.body));
	});

	// Start
	server.listen(PORT, () => console.log('Running on http://localhost:' + PORT));
}
```

## Controller

The entrypoint into the system, extended from base controller, served with a request and returning a response. Reuqests in are generic CerberusMVC requests... responses are in the form of following...

1) Generic data like text, object... (auto wraps in a promise handler for you).
2) A promise returning some form of generic data...

The data returned can be flat literals, which will auto merge with a structured response, or you can send a structured response back with the data in it.

Request data is generic accross internal and external requests in. Extra values will be present in some circumstances, body data is formatted by incoming content type.

request
```js
// dump request to find structure
console.log(request);

// request coming from a http request
// {
// 	context: { id: ..., ipAddress: ... },
// 	method: ...,
// 	path: ...,
//  access: '',
//  source: '',
// 	resource: ...,
// 	parameters: { query: {}, path: {}};
// 	headers: {},
// 	body: ...
// }

// request coming from an internal message event like SQS or similar
// {
//  context: { id: ..., service: ..., receiptHandle: ... },	
//  method: ...,
//  path: ...,
//  access: '',
//  source: '',
//  resource: ...,
//  headers: {},
//  body: ...
// }

```

response
```js

return data;

return 'OK';

return Promise.resolve('OK');

return new Promise((res, rej) => ({ some: 'data' }));

// data can be...

// just data
let data = { something: 'else' };

// or

// ensure headers are hyphoned 'Capital-Case'
let data = { status: 200, headers: {'Content-Type': 'application/json'}, body: {foo: 'bar'}};

```

```js
'use strict';

const Controller = require('cerberus-mvc/Base/Controller');

/**
 * @namespace API/Controller
 * @class Health
 * @extends Controller
 * @description Controller class exposing methods over the routed endpoint
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class Health extends Controller {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
    constructor() {
        super();
    }

	/**
	 * @public @static @get access
	 * @desciption Get the access for methods. All methods are restricted by default unless specifically set as 'public'.
	 * @return {Object} Object of access levels for methods
	 */
    static get get() { return 'public' }

    /**
     * @public @method get
     * @description Ping the system to check whats health and whats not
     * @param {*} event The event that caused the controller to run
     * @param {*} context The context of the invocation from AWS lambda
     * @return Promise a response promise resolved or rejected with a raw payload or {status: ..., data: ..., headers: ...} payload
     */
	get(event, context) {
		return {
			name: this.$environment.API_NAME,
			version: this.$environment.API_VERSION,
			mode: this.$environment.API_MODE,
			status: 'healthy',
			dateTime: new Date(),
		};
	}
}

module.exports = Health;

```

## Library

This is a good place to put tools, static classes full of helper stuff, or load in 3rd party things not in npm.

There is no structure here or stipulation, as library tools they hsould not have any interaction with the stack apart from what is written. Nothing will be exposed to a library aprt from what you pass in.

## Middleware

The sample project generated with the cli will make use of middleware bundled with the stack. You will see where the handler uses them. You can also write your won and bundle them in.

Middleware, extended from base middleware is ran in order, first to last in... then the controller is ran, then first to last out. You can inject in as an array or individually usig the auto or specific methods.

Middleware in will take in a request and should pass back out a request/modified request either directly or as a promise chain that returns it.

Example below of authentication middleware, calling an authorization service (not bundled)

```js
'use strict';

const Middleware = require('cerberus-mvc/Base/Middleware');
const RestError = require('cerberus-mvc/Error/Rest');

/**
 * @namespace API/Middleware
 * @class Auth
 * @extends Middleware
 * @description Middleware class providing authentication actions in all incomming requests
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class Auth extends Middleware {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor() {
		super();
	}

    /**
	 * @public @method in
	 * @description Invoke middleware for incomming event
     * @param {Object} request The incoming request
     */
	in(request) {
		// is this an internal message from aws?
		if (request.source === 'event') {
			// incoming only
			if (this.$client.origin) throw new RestError('Origin cannot be set on message, access denied', 401);

			// public access, do not authorize
			if (request.access !== request.context.service) throw new RestError('No access to this function for [' + request.context.service + '], access denied', 401);

			return request;
		}

		// API GATEWAY API REQUEST
		
		// incoming only
		if (!this.$client.origin) throw new RestError('Origin is not set, access denied', 401);

		// origin failed to auth to white list
		if (this.$environment.API_CORS_LIST.replace(' ', '').split(',').indexOf(this.$client.origin) < 0) throw new RestError('Origin [' + this.$client.origin + '] is not allowed, access denied', 401);

		// public access, do not authorize, gets from controllers getter that matches method
		if (request.access === 'public') return request;

		// missing token
		if (!request.headers.Authorization) throw new RestError('Missing Authorization Token, invalid', 401);

		// get token bits
		if (request.headers.Authorization.split(' ')[0].toLowerCase() !== 'bearer') throw new RestError('Malformed Token due to missing "Bearer", invalid', 401);

		// verify against auth service, throws restError on failure
		return this.$services.auth.verify(request.headers.Authorization, request.headers['User-Agent']).then(() => request);
	}
}

module.exports = Auth;

```

Middleware out will pass in a repsonse and should pass back out the response/modified response eithe rdirectly or as a promise chain returning it.

Example below of cors middleware (bundled)

```js
'use strict';

const Middleware = require('cerberus-mvc/Base/Middleware');

/**
 * @namespace MVC/Middleware
 * @class Cors
 * @extends Middleware
 * @description Middleware class providing cors patching to outgoing response
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class Cors extends Middleware {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor() {
		super();
	}

    /**
	 * @public @method out
	 * @description Invoke middleware for outgoing response
     * @param {Object} response The outgoing response to API Gateway
     * @param {Object} context The lambda context
     */
	out(response) {
		// update headers on way back out, for all requests that are not options (handled by API gateway directly)
		response.headers['Access-Control-Allow-Origin'] = this.$client.origin;
		response.headers['Access-Control-Allow-Credentials'] = 'true';
		response.headers['Access-Control-Allow-Headers'] = 'Accept, Cache-Control, Content-Type, Content-Length, Authorization, Pragma, Expires';
		response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS, PATCH';
		response.headers['Access-Control-Expose-Headers'] = 'Cache-Control, Content-Type, Authorization, Pragma, Expires';

		return response;
	}
}

module.exports = Cors;
```

## Model

Models within the system extend from the base model class, give the ability to abstract your database through inherited basic functions, transactions and also allow you to override and build on this in the individual models themselves. Use the basic built in methods, map data on inserts, get, find, updated, insert, delete and more. Want something a little more specific or want to change a base function, roll your own.

Each model connects to a table or not, allowing you to create table models or abstract models. Access the bas knex method through this.db to perform advanced functionaility.

Base class methods inherited...

* db() - the knex method
* model() - the knex method wrapped to this table
* get(id) - get a row by id, return a single row
* find(where) - get rows based on object containing keys and values
* all() - get all rows
* transaction(func) - generate a transaction as per knex
* insert(data, returning) - insert data and stipulate return data for inserted row
* transactInsert(trx, data, returning) - as above but pass in transaction
* update(where, data, returning) - update rows and return data
* transactUpdate(trx, where, data, returning) - as above but pass in transaction as per knex
* delete(id) - delete a row based on id
* softDelete(id) - soft delete, flags a deleted column with timestamp
* softRestore(id) - unflags a soft deleted data
* mapDataToColumn(data, partial) - uses the columns getter in the model to check data before inserting/updating checking required and removing anything else
* mapDataArrayToColumn(data, partial) - as above but takes an array of data to map

examples below of models...

abstract model (no table), constructor connects to db but not table (no this.model as no table, use this.db)
```js
'use strict';

const Model = require('cerberus-mvc/Base/Model');

/**
 * @namespace API/Model/Health
 * @class Health
 * @extends Model
 * @description Model class for checking system health
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class Health extends Model {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor () {
		super('air_sourcing');
	}

    /**
     * @public @method health
     * @description Ping the db to check availability
     * @return Promise a response from db service
     */
	getHealth() {
		return this.db.raw("SELECT 'healthy' AS status").then((data) => data.rows[0]);
	}
}

module.exports = Health;
```

table model, contructor takes database and table properties
```js
'use strict';

const Model = require('cerberus-mvc/Base/Model');
const SystemError = require('cerberus-mvc/Error/System');
const Crypto = require('cerberus-mvc/Library/Crypto');

const UserIdentityModel = require('../../../Model/Sourcing/Identity/UserIdentity.js');
const UserAccountModel = require('../../../Model/Sourcing/Identity/UserAccount.js');
const UserGroupModel = require('../../../Model/Sourcing/Identity/UserGroup.js');

/**
 * @namespace API/Model/Identity
 * @class User
 * @extends Model
 * @description Model class for identity.user table
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class User extends Model {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor () {
		super('db_name', 'identity.user');
	}

    /**
	 * @public @get @method columns
	 * @description Columns that we allow to be changed through requests to API
     * @return {Object} The columns data that are accessable
     */
	get columns() {
		return {
			active: { type: 'boolean', required: false, description: 'User is active' },
			name: { type: 'string', required: true, description: 'Full user name' },
			type: { type: 'enum[client][advisor][provider][admin]', required: true, description: 'User type' }
		};
	}

	/**
	 * @public @method getDetails
	 * @description Get details for all users
     * @param {Object} conditions The conditions to alter the data with e.g {limit: ..., offset: ..., order:..., direction:... }
     * @return {Promise} a resulting promise of data or error on failure
     */
	getAllDetails(conditions) {
		let query = this.db
			.select(
				'user.*',
				'user_account.id AS user_account_id',
				'user_account.ip_address AS user_account_ip_address',
				'user_account.user_agent AS user_account_user_agent',
				'user_account.login_current AS user_account_login_current',
				'user_account.login_previous AS user_account_login_previous',
				'user_identity.id AS user_identity_id',
				'user_identity.identity AS user_identity_identity',
				'user_identity.type AS user_identity_type',
				'user_identity.primary AS user_identity_primary',
				'organisation.id AS organisation_id',
				'organisation.name AS organisation_name'
			)
			.from('identity.user')
			.leftJoin('identity.user_account', 'user.id', 'user_account.user_id')
			.leftJoin('identity.user_identity', 'user.id', 'user_identity.user_id')
			.leftJoin('identity.user__department', 'user.id', 'user__department.user_id')
			.leftJoin('identity.organisation', 'user__department.department_organisation_id', 'organisation.id')
		
		if (conditions && conditions.limit) query = query.limit(Number(conditions.limit));
		if (conditions && conditions.offset) query = query.offset(Number(conditions.offset));
		console.log(22, conditions.order, conditions.direction);
		if (conditions && conditions.order) query = query.orderBy(conditions.order, conditions.direction || 'asc');

		return query.then((rows) => {
				if (rows.length < 1) [];

				let users = {};
				let ui_ids = [];
				let org_ids = [];
				for (let row of rows) {
					if (!users[row.id]) users[row.id] = { id: row.id, name: row.name, type: row.type, active: row.active, user_identity: [], organisation: [] };

					if (row.user_account_id) {
						users[row.id].user_account = {
							id: row.user_account_id,
							ipAddress: row.user_account_ip_address,
							userAgent: row.user_account_user_agent,
							loginCurrent: row.user_account_login_current,
							loginPrevious: row.user_account_login_previous
						};
					}
					
					if (row.user_identity_id && ui_ids.indexOf(row.user_identity_id) < 0) {
						users[row.id].user_identity.push({ id: row.user_identity_id, identity: row.user_identity_identity, type: row.user_identity_type, primary: row.user_identity_primary });
						ui_ids.push(row.user_identity_id);
					}

					if (row.organisation_id && org_ids.indexOf(row.organisation_id) < 0) {
						users[row.id].organisation.push({ id: row.organisation_id, name: row.organisation_name });
						ui_ids.push(row.organisation_id);
					}
				}

				return Object.values(users);
			});
	}
}

module.exports = User;
```

## Service

Services offer a way to create sington instances, for example, create an auth service, use this to login, then you can hit the auth service to get the logged in user at any point in any class that extends a base class by simple going `this.$services.auth.user`. There is one bundled service you may use right away, the knex service to create DB connections. knex is used as it allows abstraction via chaining as well as raw quesries on a number of database types. So choose to write SQL or choose to use the chaining.

Below is the example knex.js service...

```js
'use strict';

const knex = require('knex');

/**
 * @namespace API/Service
 * @class Knex
 * @extends knex (the knex base class from npm)
 * @description Service class providing database connection using knex.js
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 * @example
 * new Knex('postgres', '192.168.1.10', 5432, 'your_db', 'your_user', 'your_password');
 * or
 * new Knex({
 *		client: 'postgres',
 *		connection: {
 *			host: '192.168.1.10',
 *			port: 5432,
 *			database: 'your_db',
 *			user: 'your_user',
 *			password: 'your_password'
 *		}
 * })
 */
class Knex extends knex {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor(connClient, host, port, db, user, password) {
		// create knex
		super(typeof connClient === 'object' ? connClient : {
			client: connClient,
			connection: {
				host: host,
				port: port,
				database: db,
				user: user,
				password: password
			}
		});

		// cache
		this.service = db || connClient.connection.database;
		this.connClient = connClient;
		this.host = host;
		this.port = port;
		this.db = db;
		this.user = user;
		this.password = password;
	}
}

module.exports = Knex;
```

Other examples of services would be an authentication service... this could be used with an auth middleware to test users automatically on login.

```js
'use strict';

const JWT = require('jsonwebtoken');
const Service = require('cerberus-mvc/Base/Service');
const RestError = require('cerberus-mvc/Error/Rest');
const Crypto = require('cerberus-mvc/Library/Crypto');

const UserModel = require('../Model/Sourcing/Identity/User.js');
const UserAccountModel = require('../Model/Sourcing/Identity/UserAccount.js');

/**
 * @namespace API/Service
 * @class Auth
 * @extends Service
 * @description Service class providing authentication functionality, accessable thorughout the application
 * @author Paul Smith (ulsmith) <p@ulsmith.net> <pa.ulsmith.net>
 * @copyright 2020 Paul Smith (ulsmith) all rights reserved
 * @license MIT
 */
class Auth extends Service {

	/**
	 * @public @method constructor
	 * @description Base method when instantiating class
	 */
	constructor() {
		super();

		this.service = 'auth';
		this.user;
		this.organisation;
		this.permissions;
		this.cache;
	}

    /**
     * @public @method login
	 * @description Log a user in based on identity and password
     * @param {String} identity The resource to fetch with the given key
     * @param {String} password The resource to fetch with the given key
     * @param {String} ip The resource to fetch with the given key
     * @return Promise a resulting promise with an error to feed back or data to send on
     */
	login(identity, identityType, password, organisationID, userAgent, ip) {
		if (!identity || !password) throw new RestError('Login details incorrect, please try again.', 401);
		if (!!identityType && ['email', 'phone'].indexOf(identityType) < 0) throw new RestError('Login details incorrect, please try again.', 401);

		let userModel = new UserModel();
		let userAccountModel = new UserAccountModel();

		return userModel.getAuthedFromIdentity(identity, identityType)
			.then((user) => {
				// NOTE: need to flood prevent here too
				if (!user) throw new RestError('Login details incorrect, please try again.', 401);
				if (user.password !== Crypto.passwordHash(password, user.password.substring(0, user.password.length / 2))) throw new RestError('Login details incorrect, please try again.', 401);
				if (!user.active) throw new RestError('User is not active, please try again later.', 401);
				
				return user;
			})
			.then((user) => userModel.getUserOrganisations(user.id).then((orgs) => ({user: user, orgs: orgs})))		
			.then((userOrgs) => {
				let org = userOrgs.orgs[0];

				// we have more than one org, so user must remake request with org id, give them choice
				if (userOrgs.orgs.length > 1) {
					let orgs = userOrgs.orgs.filter((data) => data.id === organisationID);

					if (org.length !== 1) {
						throw new RestError({
							'message': 'User is part of many organisations, please add [organisationID] to request.',
							'organisations': userOrgs.orgs
						}, 403);
					}

					org = orgs[0];
				}

				// if we do have an org chosen, check active too
				if (!!org && !org.active) throw new RestError('Organisation is not active, please try again later.', 401);

				// update user, get permissions for UI and return token, only one org so must be that one
				let date = new Date();
				return userAccountModel
					.update(userOrgs.user.user_account_id, { login_current: date, login_previous: userOrgs.user.login_current, user_agent: userAgent, ip_address: ip })
					.then(() => userModel.getPermisions('ui.', userOrgs.user.id, org ? org.id : undefined))
					.then((perms) => {
						// splice in identity
						userOrgs.user.identity = identity;
						userOrgs.user.identityType = identityType;

						let result = { 
							token: this._generateJWT(userOrgs.user, org, userAgent),
							user: {
								id: userOrgs.user.id,
								name: userOrgs.user.name,
								identity: identity,
								identityType: identityType,
								loginCurrent: date,
								loginPrevious: userOrgs.user.login_current
							},
							permissions: perms
						};
						
						if (org) {
							result.organisation = {
								id: org.id,
								name: org.name,
								nameUnique: org.name_unique,
								description: org.description
							};
						}

						return result;
					});
			});
	}

    /**
     * @public @method verify
	 * @description Verify a user is still logged in. Has JWT expired?
     * @param {String} authorization The auth string from the request header, to verify
     * @return {Object} The user object to return if verified
     */
	verify(authorization, userAgent) {
		let payload;
		let jwt = authorization.replace('Bearer', '').trim();

		try {
			payload = this._verifyJWT(jwt);
		} catch(error) {
			if (error.name === 'TokenExpiredError') {
				throw new RestError({ 
					status: 'expired',
					message: 'Authorization expired, please refresh expired token.', 
					method: 'POST', 
					url: 'account/refresh',
					body: {token: jwt}
				}, 401);
			}
			
			throw new RestError({
				status: 'expired',
				message: 'Authorization failed, please log in to authorize.',
				method: 'POST',
				url: 'account/authenticate',
				body: { identity: '', password: '' }
			}, 401);
		}

		// have we switched origins?
		if (payload.aud !== this.$client.origin) throw new RestError('Origin / Token missmatch, invalid', 401);
		if (payload.userAgent !== userAgent) throw new RestError('Client browser has changed, invalid', 401);

		let userModel = new UserModel();

		return userModel.getAuthed(payload.userID)
			.then((user) => {
				if (user) return user;
				throw new RestError('User not found, please try again.', 404);
			})
			.then((user) => userModel.getUserOrganisation(user.id, payload.organisationID).then((org) => ({ user: user, org: org })))
			.then((userOrg) => userModel.getAllPermisions(userOrg.user.id, userOrg.org.id).then((perms) => ({ user: userOrg.user, org: userOrg.org, perms: perms})))
			.then((userOrgPerms) => {
				if (!userOrgPerms.user) throw new RestError('User not found, please try again.', 404);
				if (!userOrgPerms.org) throw new RestError('Organisation not found, please try again later.', 404);
				if (!userOrgPerms.user.active) throw new RestError('User is not active, please try again later.', 401);
				
				// cache user for system use
				this.user = userOrgPerms.user;
				this.user.identity = payload.userIdentity,
				this.user.identityType = payload.userIdentityType,
				this.organisation = userOrgPerms.org;
				this.permissions = userOrgPerms.perms;
				this.cache = {};
				
				// return basic user details when hit directly
				return { 
					user: {
						id: this.user.id,
						name: this.user.name,
						identity: payload.userIdentity,
						identityType: payload.userIdentityType,
						loginCurrent: this.user.login_current,
						loginPrevious: this.user.login_previous
					},
					organisation: {
						id: this.organisation.id,
						name: this.organisation.name,
						nameUnique: this.organisation.name_unique,
						description: this.organisation.description
					},
					permissions: this.permissions.filter((perm) => perm.role.indexOf('ui.') === 0)
				};
			});
	}

    /**
     * @public @method refresh
	 * @description Verify a token is valid or expired, then refresh?
     * @param {String} authorization The auth string from the request header, to verify
     * @return {Object} The user object to return if verified
     */
	refresh(authorization) {
		let jwt = authorization.replace('Bearer', '').trim();

		try {
			// if verified, just refresh anyway
			if (this._verifyJWT(jwt)) return this._refreshJWT(jwt);
		} catch (error) {
			// if expired, refresh
			if (error.name === 'TokenExpiredError') return this._refreshJWT(jwt);

			throw new RestError({
				message: 'Authorization failed, please log in to authorize.',
				method: 'POST',
				url: this.$environment.API_ADDRESS + '/account/authenticate',
				body: { identity: '', identityType: '', password: '' }
			}, 401);
		}
	}

    /**
     * @public @method isPermitted
	 * @description Handle a permission denied situation
     * @param {String} role The specific role to check as 'api.aaa.bbb' or any of a combination of roles allowed 'api.aaa/aaaa.bbb/bbbb'
     * @param {String} type The access type to check such as 'read' or more than one 'read,write,delete'
     */
	isPermitted(role, type) {
		// convert to regex, get roles and split types
		let regex = '^' + role.split('.').map((r) => r.indexOf('/') > 0 ? '(' + r.replace(/\//g, '|') + ')' : r).join('\\.') + '$';
		let roles = this.filterPermissions(new RegExp(regex));
		let types = type.split(',');

		// no roles found
		if (roles.length === 0) this.permissionDenied(role, type);
		
		// one role found
		if (roles.length === 1) {
			if (
				(types.length === 1 && !roles[0][types[0].trim()])
				|| (types.length === 2 && (!roles[0][types[0].trim()] || !roles[0][types[1].trim()]))
				|| (types.length === 3 && (!roles[0][types[0].trim()] || !roles[0][types[1].trim()] || !roles[0][types[2].trim()]))
			) this.permissionDenied(role, types[0]);
		}

		// more than one role found
		if (roles.length > 1) {
			let reduced = roles.reduce((acc, cur) => ({read: acc.read || cur.read, write: acc.write || cur.write, delete: acc.delete || cur.delete}));
			if (
				(types.length === 1 && !reduced[types[0].trim()])
				|| (types.length === 2 && (!reduced[types[0].trim()] || !reduced[types[1].trim()]))
				|| (types.length === 3 && (!reduced[types[0].trim()] || !reduced[types[1].trim()] || !reduced[types[2].trim()]))
			) this.permissionDenied(role, types[0]);
		}
	}

    /**
     * @public @method permissionDenied
	 * @description Handle a permission denied situation
     * @param {String} role The role to check
     * @param {String} type The access type to check
     */
	permissionDenied(role, type) {
		console.log(`[UserID: ${this.user.id}, OrgID: ${this.organisation.id}] No '${type}' access to '${role}' role`);
		throw new RestError(`Permission denied, you do not have '${type}' access to this resource`, 403);
	}

    /**
     * @public @method getPermission
	 * @description Fetch permission to check
     * @param {String} role The role to check
     * @return {Object} Do you have permission, permission object
     */
	getPermission(role) { return this.$services.auth.permissions.find((perm) => perm.role === role) || {} }

    /**
     * @public @method getPermissions
	 * @description Fetch permissions to check
     * @param {String} prefix The partial role prefix to match from the beginning of a role
     * @return {Array} Do you have permissions, array of permission objects
     */
	getPermissions(prefix) { return this.$services.auth.permissions.filter((perm) => perm.role.indexOf(prefix) === 0) || [] }

    /**
     * @public @method filterPermissions
	 * @description Fetch permissions to check
     * @param {Regex} regex The regex to filter on
     * @return {Array} Do you have permissions, array of permission objects
     */
	filterPermissions(regex) { return this.$services.auth.permissions.filter((perm) => regex.test(perm.role)) || [] }

    /**
     * @private @method _generateJWT
	 * @description Creates a JWT from a user object
     * @param {Object} user The user object to use for the JWT
     * @return {String} JWT token
     */
	_generateJWT(user, organisation, userAgent) {
		return JWT.sign({
			iss: this.$environment.API_ADDRESS,
			aud: this.$client.origin,
			iat: Math.floor(Date.now() / 1000),
			nbf: Math.floor(Date.now() / 1000),
			exp: Math.floor(Date.now() / 1000) + parseInt(this.$environment.JWT_EXPIRE_SECONDS),
			userID: user.id,
			userIdentity: user.identity,
			userIdentityType: user.identityType,
			organisationID: organisation ? organisation.id : undefined,
			userAgent: userAgent
		}, process.env.JWT_KEY, { algorithm: 'HS256' });
	}

    /**
     * @private @method _verifyJWT
	 * @description Verify JWT is valid
     * @param {String} token The token to verify
     * @return {Boolean} Is JWT verified or not?
     */
	_verifyJWT(token) {
		return JWT.verify(token, process.env.JWT_KEY, { algorithm: 'HS256' });
	}

    /**
     * @private @method _refreshJWT
	 * @description Verify JWT is valid
     * @param {String} token The token to verify
     * @return {Boolean} Is JWT verified or not?
     */
	_refreshJWT(token) {
		let decoded = JWT.decode(token, { complete: true });
		decoded.payload.exp = Math.floor(Date.now() / 1000) + parseInt(this.$environment.JWT_EXPIRE_SECONDS);
		return JWT.sign(decoded.payload, process.env.JWT_KEY, { algorithm: 'HS256' });
	}
}

module.exports = Auth;

```